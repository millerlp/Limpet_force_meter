---
title: "Limpet force meter analysis code"
author: ""
date: "2017-10-27"
output: word_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(replace.assign=TRUE,width=60)
knitr::opts_chunk$set(tidy=FALSE)
```

```{r calibrationFunctions, cache = TRUE}
#################################################################################
## Function loadCalibFile
## This function imports a calibration data file (.csv) with 4 columns of data
## that should be titled 'axis', 'direction', 'mass.grams', 'analogValue'.
## The input should be the file name and directory of the file
## The output will be a dataframe holding the data. 
loadCalibFile = function(fname = 'CalibrationFiles_Apr202016.csv' ,
		fdir = 'Dropbox/Limpet_force_meter/'){
	# Determine which computer we're working on so we can put the appropriate
	# file path prefix on the Dropbox file directory
	platform = .Platform$OS.type
	if (platform == 'unix'){
		prefixDrive = '~/'
	} else if (platform == 'windows'){
		prefixDrive = 'D:/'
	}
	
	fdir = paste0(prefixDrive,fdir)
	
	# Import the calibration data file
	calib = read.csv(paste0(fdir,fname))	
}
#################################################################################


################################################################################
# Function plotSeparateAxesCalib
# A function to plot the individual positive and negative calibration data for
# each of the axes (X, Y, Z). This includes the zero values for a particular 
# axis in each plot of the positive or negative direction. Note that the Z 
# axis only has one direction (positive = downwards)
# Input a data frame imported from the raw calibration data file

plotSeparateAxesCalib = function(calib = calib){
# Pull apart the separate axes calibration data, and include the zero values
	xpos = calib[calib$axis == 'X' & (calib$direction == 'zero' | 
						calib$direction == 'positive'),]
	xpos = droplevels(xpos)
	
	xneg = calib[calib$axis == 'X' & (calib$direction == 'zero' | 
						calib$direction == 'negative'),]
	xneg = droplevels(xneg)
	
	ypos = calib[calib$axis == 'Y' & (calib$direction == 'zero' | 
						calib$direction == 'positive'),]
	ypos = droplevels(ypos)
	
	yneg = calib[calib$axis == 'Y' & (calib$direction == 'zero' | 
						calib$direction == 'negative'),]
	yneg = droplevels(yneg)
	
	zneg = calib[calib$axis == 'Z' & (calib$direction == 'zero' | 
						calib$direction == 'negative'),]
	zneg = droplevels(zneg)

# Plot the raw data for each axis
	par(mfrow = c(3,2))
	#############################
# Positive X-axis
	plot(x = xpos$analogValue, y = xpos$mass.grams, type='p', 
			xlab = 'Analog count',
			ylab = 'Mass, g',
			main = 'X axis positive')
	mod = lm(mass.grams~analogValue, data = xpos)
	modSum = summary(mod)
	abline(mod)
	r2 = modSum$adj.r.squared
	mylabel = bquote(italic(R)^2 == .(format(r2, digits = 3)))
	legend('topleft', legend = mylabel, bty = 'n')
	###########################
# Negative X-axis
	plot(x = xneg$analogValue, y = xneg$mass.grams, type='p', 
			xlab = 'Analog count',
			ylab = 'Mass, g',
			main = 'X axis negative')
	mod = lm(mass.grams~analogValue, data = xneg)
	modSum = summary(mod)
	abline(mod)
	r2 = modSum$adj.r.squared
	mylabel = bquote(italic(R)^2 == .(format(r2, digits = 3)))
	legend('topright', legend = mylabel, bty = 'n')
	#######################
# Positive Y axis
	plot(x = ypos$analogValue, y = ypos$mass.grams, type='p', 
			xlab = 'Analog count',
			ylab = 'Mass, g',
			main = 'Y axis positive')
	mod = lm(mass.grams~analogValue, data = ypos)
	modSum = summary(mod)
	abline(mod)
	r2 = modSum$adj.r.squared
	mylabel = bquote(italic(R)^2 == .(format(r2, digits = 3)))
	legend('topleft', legend = mylabel, bty = 'n')
	###########################
# Negative Y-axis
	plot(x = yneg$analogValue, y = yneg$mass.grams, type='p', 
			xlab = 'Analog count',
			ylab = 'Mass, g',
			main = 'Y axis negative')
	mod = lm(mass.grams~analogValue, data = yneg)
	modSum = summary(mod)
	abline(mod)
	r2 =  modSum$adj.r.squared
	mylabel = bquote(italic(R)^2 == .(format(r2, digits = 3)))
	legend('topright', legend = mylabel, bty = 'n')
	#######################
# Z-axis
	plot(x = zneg$analogValue, y = zneg$mass.grams, type='p', 
			xlab = 'Analog count',
			ylab = 'Mass, g',
			main = 'Z axis negative')
	mod = lm(mass.grams~analogValue, data = zneg)
	modSum = summary(mod)
	abline(mod)
	r2 =  modSum$adj.r.squared
	mylabel = bquote(italic(R)^2 == .(format(r2, digits = 3)))
	legend('topleft', legend = mylabel, bty = 'n')	
}  # end of plotSeparateAxesCalib

#############################################################################
# Produce a list of calibration coefficients for the three axes. 
# The output will be a list with entries X, Y, Z, each containing a field
# 'intercept','slope', and 'R2' (R-squared)
# The regression coefficients intercept and slope will convert an input 
# analogValue into an estimate of Force (Newtons), with a positive or negative
# value depending on the direction of the force application. 

calibCoefficients = function(calib = calib){
	#########################################
	xax = calib[calib$axis == 'X',]
# Convert mass into force (Newtons) by multiplying by gravity acceleration
	xax$Force.N = (xax$mass.grams/1000) * 9.8066
# Make negative-direction values into negative forces
	xax$Force.N[xax$direction == 'negative'] = -1 * 
			xax$Force.N[xax$direction=='negative']
	#########################################
# Y-axis all data, converted to force in Newtons
	yax = calib[calib$axis == 'Y',]
# Convert mass into force (Newtons) by multiplying by gravity acceleration
	yax$Force.N = (yax$mass.grams/1000) * 9.8066
# Make negative-direction values into negative forces
	yax$Force.N[yax$direction == 'negative'] = -1 * 
			yax$Force.N[yax$direction=='negative']	
	############################################
# Z-axis all data, converted to force in Newtons
	zax = calib[calib$axis == 'Z',]
# Convert mass into force (Newtons) by multiplying by gravity acceleration
	zax$Force.N = (zax$mass.grams/1000) * 9.8066
# Make negative-direction values into negative forces
	zax$Force.N[zax$direction == 'negative'] = -1 * 
			zax$Force.N[zax$direction=='negative']
	################################################
	# Fit regressions for each axis
	modX = lm(Force.N~analogValue, data = xax)
	modXSum = summary(modX)
	# Extract intercept, slope, R^2 of regression
	myinterceptX = coef(modXSum)[1,1]
	myslopeX = coef(modXSum)[2,1]
	r2X =  modXSum$adj.r.squared
	################
	modY = lm(Force.N~analogValue, data = yax)
	modYSum = summary(modY)
	# Extract intercept, slope, R^2 of regression
	myinterceptY = coef(modYSum)[1,1]
	myslopeY = coef(modYSum)[2,1]
	r2Y =  modYSum$adj.r.squared
	################
	modZ = lm(Force.N~analogValue, data = zax)
	modZSum = summary(modZ)
	# Extract intercept, slope, R^2 of regression
	myinterceptZ = coef(modZSum)[1,1]
	myslopeZ = coef(modZSum)[2,1]
	r2Z =  modZSum$adj.r.squared
	###############################################
	# Combine data into an output list
	output = list(X = data.frame(intercept = myinterceptX, slope = myslopeX, 
					R2 = r2X),
			Y = data.frame(intercept = myinterceptY, slope = myslopeY,R2 = r2Y),
			Z= data.frame(intercept = myinterceptZ, slope = myslopeZ,R2 = r2Z))
	output
}
################################################################################


################################################################################
# Function plotAxesCalib
# This function will produce three plots (one per axis X, Y, Z) to show the 
# calibration data and regression fit to those data. The regression will use
# analogValue as the x-axis, and force in newtons (converted from mass in grams)
# for the y-axis. 
# Input should be a data frame of calibration data, with a column 'axis', 
# 'direction', 'mass.grams', and 'analogValue', produced by importing the
# raw calibration data file 

plotAxesCalib = function(calib = calib){
	######################################################
	# Combine all data for a single axis into one set, convert to force units,
	# estimate regression fit. 
	######################################################
	# X-axis all data, converted to force in Newtons
	par(mfrow=c(3,1))
	xax = calib[calib$axis == 'X',]
	# Convert mass into force (Newtons) by multiplying by gravity acceleration
	xax$Force.N = (xax$mass.grams/1000) * 9.8066
	# Make negative-direction values into negative forces
	xax$Force.N[xax$direction == 'negative'] = -1 * 
			xax$Force.N[xax$direction=='negative']
	
	plot(x = xax$analogValue, y = xax$Force.N,las = 1,
			xlab = 'Analog Count',
			ylab = 'Force, N',
			main = 'X axis')
	abline(h = 0, lty = 2, col = 'grey70')
	# Fit regression
	modX = lm(Force.N~analogValue, data = xax)
	modXSum = summary(modX)
	abline(modX)
	myinterceptX = coef(modXSum)[1,1]
	myslopeX = coef(modXSum)[2,1]
	r2 =  modXSum$adj.r.squared
	
	# Start by making an expression vector to hold the 2 lines of output:
	rp = vector('expression',2)
	
	# Write the first line, which will give R-squared and 
	# pull the value from the data frame wt.fits
	# The double == prints an equal sign when used inside expression()
	rp[1] = substitute(expression(italic(R)^2 == MYVALUE),
			list(MYVALUE = format(r2,digits = 4)))[2]
	
	# Write the 2nd line, which will pull 2 values from data frame wt.fits:
	rp[2] = substitute(expression(italic(Y) == MYVALUE2 + MYVALUE3*x),
			list(MYVALUE2 = format(myinterceptX, digits = 3),
					MYVALUE3 = format(myslopeX,digits = 3)))[2]
	# Finally, simply plot with legend() function:
	legend('topleft', legend = rp, bty = 'n')
	
	############################################
	# Y-axis all data, converted to force in Newtons
	yax = calib[calib$axis == 'Y',]
	# Convert mass into force (Newtons) by multiplying by gravity acceleration
	yax$Force.N = (yax$mass.grams/1000) * 9.8066
	# Make negative-direction values into negative forces
	yax$Force.N[yax$direction == 'negative'] = -1 * 
			yax$Force.N[yax$direction=='negative']
	
	plot(x = yax$analogValue, y = yax$Force.N,las = 1,
			xlab = 'Analog Count',
			ylab = 'Force, N',
			main = 'Y axis')
	abline(h = 0, lty = 2, col = 'grey70')
	# Fit regression
	modY = lm(Force.N~analogValue, data = yax)
	modYSum = summary(modY)
	abline(modY)
	myinterceptY = coef(modYSum)[1,1]
	myslopeY = coef(modYSum)[2,1]
	r2 =  modYSum$adj.r.squared
	
	# Start by making an expression vector to hold the 2 lines of output:
	rp = vector('expression',2)
	
	# Write the first line, which will give R-squared and 
	# pull the value from the data frame wt.fits
	# The double == prints an equal sign when used inside expression()
	rp[1] = substitute(expression(italic(R)^2 == MYVALUE),
			list(MYVALUE = format(r2,digits = 4)))[2]
	
	# Write the 2nd line, which will pull 2 values from data frame wt.fits:
	rp[2] = substitute(expression(italic(Y) == MYVALUE2 + MYVALUE3*x),
			list(MYVALUE2 = format(myinterceptY, digits = 3),
					MYVALUE3 = format(myslopeY,digits = 3)))[2]
	# Finally, simply plot with legend() function:
	legend('topleft', legend = rp, bty = 'n')
	
	############################################
	# Z-axis all data, converted to force in Newtons
	zax = calib[calib$axis == 'Z',]
	# Convert mass into force (Newtons) by multiplying by gravity acceleration
	zax$Force.N = (zax$mass.grams/1000) * 9.8066
	# Make negative-direction values into negative forces
	zax$Force.N[zax$direction == 'negative'] = -1 * 
			zax$Force.N[zax$direction=='negative']
	
	plot(x = zax$analogValue, y = zax$Force.N, las = 1,
			xlab = 'Analog Count',
			ylab = 'Force, N',
			main = 'Z axis')
	abline(h = 0, lty = 2, col = 'grey70')
	# Fit regression
	modZ = lm(Force.N~analogValue, data = zax)
	modZSum = summary(modZ)
	abline(modZ)
	myinterceptZ = coef(modZSum)[1,1]
	myslopeZ = coef(modZSum)[2,1]
	r2 =  modZSum$adj.r.squared
	
	# Start by making an expression vector to hold the 2 lines of output:
	rp = vector('expression',2)
	
	# Write the first line, which will give R-squared and 
	# pull the value from the data frame wt.fits
	# The double == prints an equal sign when used inside expression()
	rp[1] = substitute(expression(italic(R)^2 == MYVALUE),
			list(MYVALUE = format(r2,digits = 4)))[2]
	
	# Write the 2nd line, which will pull 2 values from data frame wt.fits:
	rp[2] = substitute(expression(italic(Y) == MYVALUE2 + MYVALUE3*x),
			list(MYVALUE2 = format(myinterceptZ, digits = 3),
					MYVALUE3 = format(myslopeZ,digits = 3)))[2]
	# Finally, simply plot with legend() function:
	legend('topright', legend = rp, bty = 'n')	
}
###############################################################################

```
We have the following calibration files and trial files. Note that the 
April 2016 trial data should not be analyzed, as the z-axis was not working. 
```{r importData, cache = TRUE}

if (.Platform$OS.type == 'windows'){
  fdir = "D:/Dropbox/Force Meter Files with Luke/Force Meter Data and Calibration Files/"
} else if (.Platform$OS.type == 'unix'){
  fdir = "~/Dropbox/Force Meter Files with Luke/Force Meter Data and Calibration Files/"
}


fnames = dir(fdir)
fnames  # print file names
# Do not bother with Apr 26 2016 data, the Z-axis wasn't working. 

#[1] "CalibrationFiles_Apr202016.csv"
#[2] "CalibrationFiles_Dec132016.csv"
#[3] "CalibrationFiles_Dec142016.csv"
#[4] "CalibrationFiles_Jan42017.csv" 
#[5] "CalibrationFiles_Jan52017.csv" 
#[6] "ForceMeterData_Apr262016.csv"  
#[7] "ForceMeterData_Dec142016.csv"  
#[8] "ForceMeterData_Dec152016.csv"  
#[9] "ForceMeterData_Jan52017.csv"   
#[10] "ForceMeterData_Jan62017csv.csv"
#[11] "ForceMeterData_May182016.csv"  
#[12] "ForceMeterData_May192016.csv" 

# subset names by file type (calibration or force trials)
calibfiles = fnames[grep(x = fnames, pattern = 'Calibration')]
forcefiles = fnames[grep(x = fnames, pattern = 'ForceMeterData')]
eventFile = fnames[grep(x = fnames, pattern = 'Pound_ForceData_Final.csv')]

# Load the event file
events = read.csv(paste0(fdir,eventFile))
events$Date = as.Date(events$Date, format = '%m/%d/%Y')

# Concatenate all calibration data into one data frame
for (i in 1:length(calibfiles)){
	temp = read.csv(paste0(fdir,calibfiles[i]))
	# Extract date from file name
	locs = regexpr(text = calibfiles[i],
			pattern='[[:upper:]][[:lower:]]{2}[[:digit:]]*.csv')
	month = substr(calibfiles[i],start = locs[[1]][1], 
			stop = locs[[1]][1] + 2)
	nums = regexpr(text = calibfiles[i],
			pattern='[[:digit:]]+')
	if(attr(nums,'match.length')>5){
		# 2-digit day value
		day = substr(calibfiles[i],start = nums[[1]][1],
				stop = nums[[1]][1]+1)
		yr = substr(calibfiles[i], start = nums[[1]][1]+2,
				stop = nums[[1]][1]+5)
	} else {
		# 1- digit day value
		day = substr(calibfiles[i],start = nums[[1]][1],
				stop = nums[[1]][1])
		yr = substr(calibfiles[i], start = nums[[1]][1]+1,
				stop = nums[[1]][1]+4)
	}
	# Assemble date
	temp$Date = as.Date(paste0(month,'-',day,'-',yr),format = "%b-%d-%Y")
	
	if (i == 1){
		calibs = temp
	} else {
		calibs = rbind(calibs,temp)
	}
}

if (!exists('forces')) rm(forces)

# Concatenate all force data into one data frame
for (i in 1:length(forcefiles)){
	temp = read.csv(paste0(fdir,forcefiles[i]))

	# Extract date from file name
	locs = regexpr(text = forcefiles[i],
			pattern='[[:upper:]][[:lower:]]{2}[[:digit:]]*.csv')
	month = substr(forcefiles[i],start = locs[[1]][1], 
			stop = locs[[1]][1] + 2)
	nums = regexpr(text = forcefiles[i],
			pattern='[[:digit:]]+')
	if(attr(nums,'match.length')>5){
		# 2-digit day value
		day = substr(forcefiles[i],start = nums[[1]][1],
				stop = nums[[1]][1]+1)
		yr = substr(forcefiles[i], start = nums[[1]][1]+2,
				stop = nums[[1]][1]+5)
	} else {
		# 1- digit day value
		day = substr(forcefiles[i],start = nums[[1]][1],
				stop = nums[[1]][1])
		yr = substr(forcefiles[i], start = nums[[1]][1]+1,
				stop = nums[[1]][1]+4)
	}
	# Assemble date	
	thisDate = as.Date(paste0(month,'-',day,'-',yr),format = "%b-%d-%Y")
	if (thisDate == as.Date('2016-04-26')){
		# skip any file from 2016-04-26
	} else {
		# Remove columns that don't match these names:
		keepCols = c('Time.msec.','JOY_X_signal','JOY_Y_signal','BEAM_Z_signal')
		temp = temp[,keepCols]
		names(temp)[1] = 'Time.msec'
		temp$Date = thisDate
		
		if (!exists('forces')){
			forces = temp
		} else {
			forces = rbind(forces,temp)
		}
	}
	
}

# Rename the Time.msec. column to Time.msec
#names(forces)[1] = 'Time.msec' 

```

The relevant calibration file for the May 2016 trials is the Apr202016 file.

During the import process, the calibration files and force trial files are 
concatenated together into two data frames, `calibs` and `forces`, each with a
`Date` column that can be used to separate different days. The data frame
`events` contains the identified peck and push events, with dates and
millisecond timestamps. 


The goal is to go through each identified event and extract the X-axis and 
Y-axis forces (which need to be estimated based on the associated calibration
values). The `events` data frame currently only has the net euclidean norm 
(total for all 3 axes).

```{r calibDetermination, cache = FALSE}
# For each date in the 'calibs' data frame, fit regressions to each axis
# and determine conversions from raw counts to force in Newtons. 



dates = unique(calibs$Date)

# 2016-04-20 calibration goes with May 18 + 19 2016 ForceMeterData
# 2016-12-13 calibration goes with Dec 14 2016 ForceMeterData
# 2016-12-14 calibration goes with Dec 15 2016 ForceMeterData
# 2017-01-04 calibration goes with Jan 5 2017 ForceMeterData
# 2017-01-05 calibration goes with Jan 6 2017 ForceMeterData

for (i in 1:length(dates)){
  # subset the calibs by date
  temp = calibs[calibs$Date == dates[i],]
  
  tempCalib = calibCoefficients(temp)
  # Assemble into a list based on date
  if (i == 1){
    calibCoeffs = list()
    calibCoeffs[[1]] = tempCalib 
    calibCoeffs[[i]]$Date = dates[i]
    # names(calibCoeffs[1]) = dates[i]
  } else if (i > 1) {
    calibCoeffs[[i]] = tempCalib
    calibCoeffs[[i]]$Date = dates[i]
  }
}


for (j in 1:length(calibCoeffs)){
	if (j == 1){
		calibDates = calibCoeffs[[j]]$Date	
	} else {
		calibDates = c(calibDates,calibCoeffs[[j]]$Date)
	}
}

```


```{r stepThroughEvents, cache = TRUE}

# Go through each events in the events data frame, pull out the relevant time
# which should be in the Time_msec column and the 
# associated Date. Then go find the relevant rows in the forces data frame
# to get the raw JOY_X_signal, JOY_Y_signal, and BEAM_Z_signal for a chunk of 
# just before and after the event. Use the relevant calibration data to convert
# each channel to forces in Newtons, 
events2 = events # make a copy
events2$X.N = NA  # make empty columns
events2$Y.N = NA
events2$Z.N = NA
for (i in 1:length(events$Event)){
	dateval = events[i,'Date']
	msecval = events[i,'Time_msec']
# Go into forces and find the time point
# Start by subsetting by Date
	temp = forces[forces$Date == dateval,]
	timeMatch = which.min(abs(temp$Time.msec - msecval))
# Grab some rows ahead and after the timeMatch
	temp2 = temp[(timeMatch-100):(timeMatch+100),c('JOY_X_signal','JOY_Y_signal',
					'BEAM_Z_signal','Time.msec','Date')]
# Use the initial rows as a local zero offset reading to apply the calibration.

# 2016-04-20 calibration goes with May 18 + 19 2016 ForceMeterData
# 2016-12-13 calibration goes with Dec 14 2016 ForceMeterData
# 2016-12-14 calibration goes with Dec 15 2016 ForceMeterData
# 2017-01-04 calibration goes with Jan 5 2017 ForceMeterData
# 2017-01-05 calibration goes with Jan 6 2017 ForceMeterData

	# Use the calib file from the day before the force dateval (i.e. the
	# date closest to dateval-1)
	tempcalibs = calibCoeffs[[which.min(abs(calibDates - (dateval-1)))]]
	
	##############################################
# Convert raw count data to forces
	temp2$X.N = (temp2$JOY_X_signal * tempcalibs$X$slope) + 
			tempcalibs$X$intercept
	temp2$Y.N = (temp2$JOY_Y_signal * tempcalibs$Y$slope) + 
			tempcalibs$Y$intercept
	temp2$Z.N = (temp2$BEAM_Z_signal * tempcalibs$Z$slope) + 
			tempcalibs$Z$intercept
	##################
# Calculate an offset from 'zero' for each axis using the first few samples
# where there is presumably no force being exerted
	xoffset = mean(temp2$X.N[1:50])
	temp2$X.N = temp2$X.N - xoffset
	yoffset = mean(temp2$Y.N[1:50])
	temp2$Y.N = temp2$Y.N - yoffset
	zoffset = mean(temp2$Z.N[1:50])
	temp2$Z.N = temp2$Z.N - zoffset 
# Take the focal time match and write it into the new columns of the events2 
	# data frame.
	events2[i,'X.N'] = temp2$X.N[101]
	events2[i,'Y.N'] = temp2$Y.N[101]
	events2[i,'Z.N'] = temp2$Z.N[101]
	
# Also generate a list containing an entry for each event that will hold the
	# relevant time points
	if (i == 1){
		forceList = list()
	} 
	forceList[[i]] = temp2
	forceList[[i]]$Event = events[i,'Event']
	# Calculate the euclidean norm of all three axes forces
	xyz = as.matrix(forceList[[i]][,c('X.N','Y.N','Z.N')])
	for (k in 1:nrow(xyz)){
		# norm() function computes the norm. Needs to work on one row of data at
		# a time
		forceList[[i]]$Norm[k] = norm(xyz[k,],"2")	
	}
	
}	
# Save output
# write.csv(events2,file='Pound_ForceData_withXYZ_forces.csv',row.names=FALSE)

```

```{r test, eval = FALSE, echo = FALSE}
eNum = 3
timepts = 90:120
ylims = range(forceList[[eNum]][,c("X.N","Y.N","Z.N","Norm")])
ylims[1]=floor(ylims[1])
ylims[2]=ceiling(ylims[2])
cexlab = 1.5
cexaxs = 1.5
par(mar = c(5,5.5,3,1))
showEvents = TRUE  # turn the vertical lines marking the event(s) on or off
# Generate base plot
plot(x = forceList[[eNum]]$Time.msec[timepts],forceList[[eNum]]$X.N[timepts], 
		type = 'b', col = 'orange', ylim = ylims, 
		xlab = 'Elapsed time, milliseconds',
		ylab = 'Force, N', las = 1, cex.axis = cexaxs, 
		cex.lab = cexlab)
rect(par()$usr[1],par()$usr[3],par()$usr[2],par()$usr[4],col='grey90')
grid(col='white',lty = 2)
abline(h= 0, lty = 2, col = 'black')
if(showEvents){
# Add a vertical line at the event time, which should be entry 101 if we 
# extracted the 100 time points before and after each event's Time.msec value
abline(v = forceList[[eNum]]$Time.msec[101])
# Also plot a marker for the next event, and if it shows up in the plot, it 
# may indicate that the two events are too close together
abline(v = forceList[[eNum+1]]$Time.msec[101], lty = 2)
}
# Plot the individual force traces
lines(x = forceList[[eNum]]$Time.msec[timepts],
		forceList[[eNum]]$X.N[timepts], col = 'forestgreen')
points(x = forceList[[eNum]]$Time.msec[timepts],
		forceList[[eNum]]$X.N[timepts], col = 'forestgreen', pch = 20, cex = .75)
lines(x = forceList[[eNum]]$Time.msec[timepts],
		forceList[[eNum]]$Y.N[timepts], col = 'blue')
points(x = forceList[[eNum]]$Time.msec[timepts],
		forceList[[eNum]]$Y.N[timepts], col = 'blue', pch = 20, cex = .75)
lines(x = forceList[[eNum]]$Time.msec[timepts],
		forceList[[eNum]]$Z.N[timepts], col = 'red')
points(x = forceList[[eNum]]$Time.msec[timepts],
		forceList[[eNum]]$Z.N[timepts], col = 'red', pch = 20, cex = .75)
# Plot the norm
lines(x = forceList[[eNum]]$Time.msec[timepts],
		forceList[[eNum]]$Norm[timepts],col='orange')
mtext(side = 3, text = paste0('Event ',forceList[[eNum]]$Event,", ",
				forceList[[eNum]]$Date[1]), line = 1,
		cex = 2)
legend('topleft', legend = c('X','Y','Z','Norm (Net Force)'),
		col = c('forestgreen','blue','red','orange'), lwd = 2, bty = 'n')


```

## DEFINTIONS

* A given force can only be assigned to one category (cannot be a push and peck)
* Forces discussed below refer to Euclidean forces

### Peck:

* Magnitude: ≥ 2N and MUST BE greater than or equal to two times the
intensity of the force data points immediately before AND after a given point. 
* Duration: Force MUST BE sustained for ≤ 2 consecutive milliseconds
* Both magnitude and duration conditions must be met in order for a force
to be categorized as a peck

### Push:

* Magnitude: ≥ 2N and may or may not be greater than or equal to two times
the intensity of the force before and after a given force data point
* Duration:  May be sustained for any amount of time
* Forces categorized as pushes do not meet conditions of Peck and Touch

### Touch:

* Magnitude: < 2N  (e.g. the bird seems to be playing with the ‘limpet’
mimic rather than actively attempting to remove it)
* We are not considering ‘Touches’ in our force meter analyses


```{r PushPeckPick, eval = FALSE}
# TODO: implement a process to have the user identify the baseline before each
# peak and then identify 1 or more peak/pushes to be saved as events. 

# Code to run through a data set and have the user identify probable push or 
# peck events. 
# All data are in the forces data frame

# Step through rows of forces data frame, plot a chunk of time vs Norm, and
# have user select any events that look like pecks or pushes. Then categorize
# the event and write the time values out to a new events data frame. 

# Since forces data frame only has raw signals, we need to apply the 
# calibration values to each chunk of data to convert to Newtons and calculate
# the norm. 
library(RANN) # for nn2 nearest neighbor search function

myDates = unique(forces$Date)

# Subset by date, since that affects calibration values
for (dayDate in 1:length(myDates)){
	# Extract force data for the current date
	dat = forces[forces$Date == myDates[dayDate],]
	nsamps = nrow(dat)
	# Get the relevant calibration data from calibCoeffs list
	
	tempcalibs = calibCoeffs[[which.min(abs(calibDates-(myDates[dayDate]-1)))]]
	
	
	dat$X.N = (dat$JOY_X_signal * tempcalibs$X$slope) + 
			tempcalibs$X$intercept
	dat$Y.N = (dat$JOY_Y_signal * tempcalibs$Y$slope) + 
			tempcalibs$Y$intercept
	dat$Z.N = (dat$BEAM_Z_signal * tempcalibs$Z$slope) + 
			tempcalibs$Z$intercept
	
	
	# Make a plot of raw sample data to have user select a baseline time period
	
	repeatLoop = TRUE
	for (j in seq(1,nsamps, by = 1000)){
		while(repeatLoop == TRUE){

			ylims = range(dat$JOY_X_signal)
			plot(dat$Time.msec[j:(j+999)],y = dat$JOY_X_signal[j:(j+999)],type='l',
					ylim = ylims, xlab = 'Time, ms', yaxs='i')
			par(xpd = TRUE)
#		greenlocsx = c(dat$Time.msec[j],dat$Time.msec[j+200],
#				dat$Time.msec[j+200],dat$Time.msec[j])
#		greenlocsy = c(ylims[2],ylims[2],ylims[2]+100,ylims[2]+100)
#		polygon(greenlocsx,greenlocsy,col='green')
			# Button for skipping ahead to next section
			bluelocsx = c(dat$Time.msec[j+800],dat$Time.msec[j+1000],
					dat$Time.msec[j+1000],dat$Time.msec[j+800])
			bluelocsy = c(ylims[2],ylims[2],ylims[2]+100,ylims[2]+100)
			polygon(bluelocsx,bluelocsy,col='lightblue')
			text(x = dat$Time.msec[j+900],y = ylims[2]+50, labels='skip ahead')
			# Put message on plot
			text(x = par()$usr[1], y = ylims[2]+50,
					labels = 'Click on peak to zoom in\n or click blue button\n to skip ahead',
					adj = 0)
			clickLocation = locator(n = 1)
			if (clickLocation$x > bluelocsx[1] & 
					clickLocation$x < bluelocsx[2] &
					clickLocation$y > bluelocsy[1] & 
					clickLocation$y < bluelocsy[3]) {
				# User clicked in the skip ahead box
				print("skip ahead")
				skip = TRUE
				zoom = FALSE
			} else if (clickLocation$x > par()$usr[1] &
					clickLocation$x < par()$usr[2] & 
					clickLocation$y > par()$usr[3] & 
					clickLocation$y < par()$usr[4]) {
				# user clicked somewhere else in the figure, decide if it was 
				# a value location to click
				print('click in plot')
				points(x = clickLocation$x, y = clickLocation$y, col = 'red',
						pch = 20, cex = 1.5)
				zoom = TRUE
				skip = FALSE
			} else {
				# Trigger a re-plot
				print('click not in field')
				clickLocation
				zoom = FALSE
				skip = FALSE 			
			}
				
			if (zoom == FALSE & skip == TRUE){
				# cycle main loop again to move to next chunk of time			
				break  # break out of while loop
			} else if (zoom == TRUE & skip == FALSE) { 
				# zoom in
				# Find the row of dat closest to the click location
				clickRow = which.min(abs(clickLocation$x - dat$Time.msec))
				# subset a new data frame centered around the clickRow
			    temp = dat[(clickRow-100):(clickRow+100),]
	
	
				# Now the user will choose a time point that represents the
				# baseline force value for upcoming peaks
				ylims = range(temp$JOY_X_signal)
				xlims = range(temp$Time.msec)
				plot(temp$Time.msec,
						y = temp$JOY_X_signal,
						type = 'l', 
						ylab = 'Raw x-axis signal', xlab = 'Time, ms')
				par(xpd=TRUE)
				bluelocsx = c(xlims[1]+1600,xlims[1]+2200,
						xlims[1]+2200,xlims[1]+1600)
				bluelocsy = c(ylims[2],ylims[2],ylims[2]+100,ylims[2]+100)
				polygon(bluelocsx,bluelocsy,col='lightblue')
				text(x = xlims[1]+1600,y = ylims[2], 
						labels='Skip to next section', adj = c(-0.1,-1))
#				pinklocsx = c(xlims[1]+1000,xlims[1]+1600,
#						xlims[1]+1600,xlims[1]+1000)
#				pinklocsy = c(ylims[2]+20,ylims[2]+20,ylims[2]+100,ylims[2]+100)
#				polygon(pinklocsx,pinklocsy,col='pink')
#				text(x = xlims[1]+1000,y = ylims[2]+50, 
#						labels='Done selecting', adj = 0)
				text(x=par()$usr[1], y = par()$usr[4],
						labels='Click a baseline point or hit move', adj = c(0,0))

				clickLocation = locator(n = 1)
				if (clickLocation$x > bluelocsx[1] & 
						clickLocation$x < bluelocsx[2] &
						clickLocation$y > bluelocsy[1] & 
						clickLocation$y < bluelocsy[3]) {
					# User clicked in box to move ahead
					break
#					} else if (clickLocation$x > pinklocsx[1] & 
#							clickLocation$x < pinklocsx[2] &
#							clickLocation$y > pinklocsy[1] & 
#							clickLocation$y < pinklocsy[3]){
					# User click
				} else if (clickLocation$x > par()$usr[1] &
						clickLocation$x < par()$usr[2] & 
						clickLocation$y > par()$usr[3] & 
						clickLocation$y < par()$usr[4]) {
					# User clicked on baseline plot, find nearest row
					baseLocRow = which.min(abs(clickLocation$x - 
											temp$Time.msec))
					# Use the chosen row value to work out a baseline value
					# to use with the calibrations
				}
				
				##########################
				# With a baseline location in hand, calculate calibrated force
				# values and replot the norm'd forces
				
				##################
				# Calculate an offset from 'zero' for each axis using the first few samples
				# where there is presumably no force being exerted
				xoffset = mean(temp$X.N[baseLocRow:(baseLocRow+20)])
				temp$X.N.off = temp$X.N - xoffset
				yoffset = mean(temp$Y.N[baseLocRow:(baseLocRow+20)])
				temp$Y.N.off = temp$Y.N - yoffset
				zoffset = mean(temp$Z.N[baseLocRow:(baseLocRow+20)])
				temp$Z.N.off = temp$Z.N - zoffset 
				# Calculate euclidean norm force
				for (r in 1:nrow(temp)){
					xyz = as.matrix(temp[r,c('X.N.off','Y.N.off','Z.N.off')])
					temp$Norm[r] = norm(xyz,'2')
				}
				################################################################
				# Have user identify peaks here to be classified as peak/push
				xlims = range(temp$Time.msec)
				ylims = range(temp$Norm)
				plot(x = temp$Time.msec, y = temp$Norm,type='b', 
						xlab = 'Time, msec', ylab = 'Norm, Newtons', las = 1)
				par(xpd=FALSE)
				grid(col = 'grey70',lty = 2)
				abline(h = 2, lty = 2, col = 'red')
				par(xpd=TRUE)
				bluelocsx = c(xlims[1]+1650,xlims[1]+2200,
						xlims[1]+2200,xlims[1]+1650)
				bluelocsy = c(ylims[2]+1,ylims[2]+1,ylims[2]+100,ylims[2]+100)
				polygon(bluelocsx,bluelocsy,col='lightblue')
				text(x = xlims[1]+1700,y = ylims[2]+3, 
						labels='Done choosing', adj = 0)
				keepChoosing = TRUE
				while(keepChoosing == TRUE){
					clickLocation = locator(n = 1) # have user select a point
					# Draw where the user clicked
					points(x=clickLocation$x,y=clickLocation$y,col='red',
							pch = 20)
					if (clickLocation$x > bluelocsx[1] & 
							clickLocation$x < bluelocsx[2] &
							clickLocation$y > bluelocsy[1] & 
							clickLocation$y < bluelocsy[3]) {
						# User clicked in box to say they are done choosing
						break  # kill the while(keepChoosing == TRUE) loop
					} else if (clickLocation$x > par()$usr[1] &
							clickLocation$x < par()$usr[2] & 
							clickLocation$y > par()$usr[3] & 
							clickLocation$y < par()$usr[4]) {
						# User clicked on plot, find nearest point
						# by using a nearest neighbor search algorithm using
						# the function nn2 from the package 'RANN'
						# Prepare the data matrix
						mymatrix = cbind(temp$Time.msec,temp$Norm)
						# Rescale the x-axis data, since the results of nn2
						# will be thrown off if the scale of x data is very 
						# different from the scale of y data
						mymatrix[,1] = mymatrix[,1]/1000
						mypoint = cbind(clickLocation$x,clickLocation$y)
						# Also rescale the clickLocation x-axis value
						mypoint[,1] = mypoint[,1]/1000
						# Run the nearest neighbor search. The k=1 argument
						# should return the 1st-closest nearest neighbor
						rowIndex = nn2(data=mymatrix,query=mypoint,k = 1)$nn.idx[1,1]
						# Add the identified point to the plot
						points(temp$Time.msec[rowIndex],y=temp$Norm[rowIndex],
								pch = 20, col = 'royalblue')
						# Use the chosen row value to work out a baseline value
						# to use with the calibrations
						keepChoosing = TRUE
						if(!(exists('peakPushEvents'))){
							# Get the appropriate row of info out of the
							# original data frame dat
							peakPushEvents = temp[rowIndex,]
							# Also add on the Time.msec value for the baseline
							# point
						    peakPushEvents$BaselineTime.msec = temp$Time.msec[baseLocRow]
						} else {
							# If peakPushEvents exists, add onto it
							tempVals = temp[rowIndex,] # extract the peak row
							# Add on the baseline row Time.msec value
							tempVals$BaselineTime.msec = temp$Time.msec[baseLocRow]
							# rbind the new data onto peakPushEvents
							peakPushEvents = rbind(peakPushEvents,
									tempVals)
						}
						keepChoosing = TRUE # allow while loop to repeat
					} # end of if (clickLocation$x > bluelocsx[1]... section
				} # end of while(keepChoosing == TRUE)

			} else if (zoom == FALSE & skip == FALSE ){
				# let the main plot loop repeat (plots a wide-angle view)
				repeatLoop = TRUE 
			}
		} # end of while(repeatLoop == TRUE) 

	}

}



```


